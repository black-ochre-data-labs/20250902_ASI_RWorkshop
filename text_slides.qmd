---
title: "Working With Text"
subtitle: "ASI: Introduction to R"
author: "Dr Stevie Pederson"
institute: |
  | Black Ochre Data Labs
  | The Kids Research Institute Australia
date: "2025-09-02"
date-format: long
bibliography: bibliography.bib
title-slide-attributes:
    data-background-color: "#3c3c44"
    data-background-image: assets/bodl_logo_white_background.jpg
    data-background-opacity: "0.3"
    data-background-size: "90%"
editor: source
format: 
  revealjs:
    theme: [bodl.scss]
    code-line-numbers: false
    width: 1280
    height: 720
    sansfont: Times New Roman
    logo: assets/bodl_logo_white_background.jpg
    slide-number: c
    show-slide-number: all
  html: 
    css: [bodl.scss, extra.css]
    output-file: text.html
    embed-resources: true    
    toc: true
    toc-depth: 2
include-after: |
  <script type="text/javascript">
    Reveal.on('ready', event => {
      if (event.indexh === 0) {
        document.querySelector("div.has-logo > img.slide-logo").style.display = "none";
      }
    });
    Reveal.addEventListener('slidechanged', (event) => {
      if (event.indexh === 0) {
        Reveal.configure({ slideNumber: null });
        document.querySelector("div.has-logo > img.slide-logo").style.display = "none";
      }
      if (event.indexh === 1) { 
        Reveal.configure({ slideNumber: 'c' });
        document.querySelector("div.has-logo > img.slide-logo").style.display = null;
      }
    });
  </script>    
knitr: 
  opts_chunk: 
    echo: true
    results: markup
    include: true
    warning: false
    message: false
    fig.align: center  
    fig.height: 6
    fig.width: 8  
---

# Text Strings {background-color="#3c3c44" background-image=https://stringr.tidyverse.org/logo.png background-size="40%" background-opacity="0.5" background-position="75% 30%"}

## Text Manipulation

Wrangling text is a common task using `R`

::: {.fragment}
- Renaming columns for better axis/legend labels in `ggplot`
    + Change to title case
    + Remove underscores & replace with spaces
    
:::

::: {.fragment}
- Correcting data entry errors
    + "Y", "yes", "No"
    
:::

::: {.fragment}
- Extracting key information from filenames
    + "sample01_treat.bam", "sample01_control.bam"
    
:::

## Session Outline

- Basic string manipulation using `stringr`
    + Is loaded with the `tidyverse`
- Brief introduction to *regular expressions*
- Categorical variables using `forcats`
    + Also loaded with the `tidyverse`


## Text Manipulation

::: {style="font-size:99%"}

- Start a new R script: `text.R`

```{r}
library(tidyverse)
```

- Next, create the vector we'll mess around with

```{r}
## Create a character vector for this session
treats <- c("apple pie", "banana split", "cherry tart", "apple crumble", "banana bread")
```
 
:::

## Key Utility Functions

- Changing case is common and straightforward

```{r}
## Convert every character to upper-case
str_to_upper(treats)
## Convert the first letter of every word to upper-case
str_to_title(treats)
## Convert the first letter of the first word to upper-case
str_to_sentence(treats)
```

::: {.fragment}
- `str_to_lower()` won't have any effect here
:::

## Key Utility Functions {.slide-only .unlisted}

- Sometimes really long strings can be truncated
    + The length will be fixed at the given width
    + Any exceeding this will have `...` in the last 3 positions

```{r}
str_trunc(treats, 10)
```

::: {.fragment}
- Line breaks in `R` are encoded with `"\n"`
- Can wrap axis labels at a maximum length

```{r}
str_wrap(treats, 10)
```


:::

## Key Utility Functions {.slide-only .unlisted}


- We can simply count the number of characters

```{r}
str_length(treats)
```


::: {.fragment}


- Padding strings can be super-helpful when dealing with numbers

```{r}
1:10
str_pad(1:10, width = 2, pad = "0")
```

:::

## Pattern Detection


```{r}
## Find which values match a given pattern
str_detect(treats, "nana")
```


::: {.fragment}

- `str_detect()` contains a `negate` argument
- Flips the results to those NOT matching the pattern


```{r}
## Find which values DON'T match a given pattern
str_detect(treats, "nana", negate = TRUE)
```

:::

## Extracting Patterns

- We can *extract* patterns from each value

```{r}
str_extract(treats, "apple")
```

::: {.fragment}

- Or we can simply remove them
    + I've also removed the space after apple here

```{r}
str_remove(treats, "apple ")
```

:::

## Replacing Patterns

```{r}
## Replace the space with an underscore
str_replace(treats, pattern = " ", replacement = "-")
```

::: {.fragment}
<br>

```{r}
## Replace an `a` with `u`
str_replace(treats, pattern = "a", replacement = "u")
```

- Note this only replaced the first occurence

:::
::: {.fragment}

```{r}
## Replace all `a`s with `u`s
str_replace_all(treats, pattern = "a", replacement = "u")
```

:::

## Using `_all` versions

```{r}
str_remove(treats, "a")
str_remove_all(treats, "a")
```


## Using `_all` versions {.slide-only .unlisted}

- `str_extract_all()` produces an `R` object known as a `list`
    + A bit trickier to work with
    
```{r}
str_extract(treats, "na")
str_extract_all(treats, "na")
```
    
# Regular Expressions {background-color="#3c3c44"}

## Regular Expressions

- Regular Expressions allow more powerful pattern matching. We can:
    + match sets of characters
    + include wildcards
    + capture multiple patterns and return in any order

::: {.fragment}
- `regex` exist in most languages (e.g. `python`, `bash` etc)
- `R` does have some unique syntax
- Too complex for our time-frame $\implies$ just a brief introduction
:::


## Sets Of Characters

- Sets can be specified using `[]`
    + `[aeiou]` would match any vowel
    + `[abc]` would match either `a`, `b` or `c`

::: {.fragment}
- Sets can include ranges
    + `[A-Z]` for any uppercase letter
    + `[a-z]` for any lowercase letter
    + `[0-9]` for any number

:::


## Sets Of Characters {.slide-only .unlisted}

- Predefined sets also exist
    + `[:alpha:]` matches any alphabetic character
    + `[:alnum:]` matches any alpha-numeric character
- All defined at `?regex`

## Sets Of Characters {.slide-only .unlisted}


```{r}
## Remove all vowels using [aeiou]
str_remove_all(treats, pattern = "[aeiou]")
```

::: {.fragment}
<br>

```{r}
## Replace all vowels with a dash
str_replace_all(treats, pattern = "[aeiou]", replacement = "-")
```

:::

## Wildcards

- Unlike many common-use situations, the `regex` wildcards is `.`
    + `*` has a different meaning
    
    
```{r}
## Extract the letter a followed by anything
str_extract(treats, "a.")
```

## Extending Matches

- Matches can be extended by adding `+`
    + Matches the previous *one or more times*
    + `*` matches *zero or more times*
- If using `.+` $\implies$ one or more wildcards 


```{r}
## Extract a followed by a wildcard, one or more times
str_extract(treats, "a.+")
## Extract the first word from each treat
str_extract(treats, "[a-z]+")
```

## Capturing Patterns

- Placing a pattern inside `()` "captures" the pattern
    + Can be returned in the replacement
- Captured patterns are given numbers $\implies$ the first capture is `1`
    + In `R` we return captures using `\\1`, `\\2` etc
    
```{r}
## Capture each word, then return in the opposite order
str_replace_all(treats, "([a-z]+) ([a-z]+)", "\\2 \\1")
## Just return one of the words amongst other text
str_replace_all(treats, "([a-z]+) ([a-z]+)", "I'd like \\2 for dessert")
```

## Anchoring Patterns

- A pattern can be anchored to the start of a string using `^`

```{r}
## Match any pattern with an `a`
str_detect(treats, "a")
## Ensure the `a` is the first character
str_detect(treats, "^a")
```

::: {.fragment}

- A pattern can also be anchored to the end of a string using `$`

```{r}
## Match any pattern with an `e`
str_detect(treats, "e")
## Ensure the `e` is the last character
str_detect(treats, "e$")
```


:::

## Excluding Characters

- To make things confusing, placing `^` inside `[]` negates the character inside `[]`

```{r}
## Remove all vowels
str_remove_all(treats, "[aeiou]")
## Remove everything that isn't a vowel
str_remove_all(treats, "[^aeiou]")
```

## Escaping Characters

- The use of special characters (e.g. `^`, `$`, `.`, `+`, `*`, `[`, `]`, `(`, `)`) is very powerful

::: {.fragment}
- What if we need to exactly match one of them?
    + Most commonly we need to match a `.` within a file name
    
:::

::: {.fragment}
- We escape *the default meaning of a value* using `\\`
    + This is how `\\1` returns captures instead of the value `1`
    + To match `.` exactly, we use `\\.`

:::


## Challenges

1. Replace the `0` at the beginning of these phone numbers with `+61`

```{r}
phones <- c("0499123456", "0498760432")
```

2. Remove the transcript version numbers from the following 

```{r}
ids <- c("ENST00000376207.10", "ENST00000376199.7")
```

::: {.callout-note collapse="true"}
Most challenges can be solved more than one way. The right way is the one that works!
:::

# Categorical Variables {background-color="#3c3c44" background-image=https://forcats.tidyverse.org/logo.png background-size="40%" background-opacity="0.5" background-position="75% 30%"}

## Factors

- Categorical Variables are called *factors* in `R`
- Well handled by the package `forcats`
    + Is loaded with `library(tidyverse)`

::: {.fragment}
- Can look like text strings but are subtly different
    + Multiple repeated values $\implies$ categories
    + e.g. The islands in the penguins dataset
    
:::

## Factors {.slide-only .unlisted}

- Character vectors will always display values surrounded by quotation marks
- Factors display values *without* quotation marks [except in a `tibble`]{.fragment fragment-index=1}

:::: {.columns}

::: {.column}

```{r}
dose <- c("High", "Med", "Low")
dose
as.factor(dose)
```

:::

::: {.column}

::: {.fragment fragment-index=1}

```{r}
tibble(
  dose = dose, 
  factor = as.factor(dose)
)
```

:::
:::

::::

## Factors {.slide-only .unlisted}

- `as.factor()` will set categories (i.e. levels) in alpha-numeric order
    + Will be coerced automatically when plotting

```{r}
## Notice the category levels are in order
## High Low Med
as.factor(dose)
```

::: {.fragment}

- We can set manually using `factor()`

```{r}
factor(dose, levels = c("Low", "Med", "High"))
```

:::

## Using `forcats`

- `as.factor()` and `factor()` are in the package `base`
- `forcats` provides `as_factor()` and `fct()`
    + Very similar, but can differ in automatic ordering
    
::: {.fragment}
- Can easily set levels by frequency: `fct_infreq()`
    + Or in revers: `fct_rev()`
    
:::

::: {.fragment}
- Low frequency categories can be merged: 
    + `fct_lump()`, `fct_lump_n()`,  `fct_lump_prop()`
    
:::

## Using `forcats` {.slide-only .unlisted}

- `NA` values can be set to a specific level
    + `fct_na_value_to_level()`
    
::: {.fragment}
- `stringr` functions can be used to tidy levels:
    + `fct_relabel(f, .fun)`

:::
    
